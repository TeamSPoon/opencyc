package  org.opencyc.jini.shared;

/**
 * Wraps Jini client-side methods on behalf of a client agent.
 * @see ClientHelperCallbackInterface
 *
 * @version $Id$
 * @author Stephen L. Reed
 *
 * <p>Copyright 2001 Cycorp, Inc., license is open source GNU LGPL.
 * <p><a href="http://www.opencyc.org/license.txt">the license</a>
 * <p><a href="http://www.opencyc.org">www.opencyc.org</a>
 * <p><a href="http://www.sourceforge.net/projects/opencyc">OpenCyc at SourceForge</a>
 * <p>
 * THIS SOFTWARE AND KNOWLEDGE BASE CONTENT ARE PROVIDED ``AS IS'' AND
 * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OPENCYC
 * ORGANIZATION OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE AND KNOWLEDGE
 * BASE CONTENT, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import  java.io.IOException;
import  java.rmi.*;
import  java.rmi.server.*;
import  net.jini.core.entry.*;
import  net.jini.core.event.*;
import  net.jini.core.lease.*;
import  net.jini.lease.*;
import  org.opencyc.util.*;


public class ClientHelper {
    /**
     * The client agent for which this object provides Jini
     * helper methods.
     */
    private ClientHelperCallbackInterface client;

    /**
     * Class of the service agent used to find available service.
     */
    private Class serviceClass;

    /**
     * Entry attribute used to match available services.
     */
    private Entry entryAttribute;

    /**
     * The service object viewed generically, providing encapsulation from
     * the specific service used by the client.
     */
    private GenericServiceInterface serviceInterface;

    /**
     * Service name.
     */
    String name;

    /**
     * A lease renewal manager to automatically renew leases on behalf of the client agent.
     */
    private LeaseRenewalManager lrm;

    /**
     * The client's lease on services provided.
     */
    private Lease serviceLease;

    /**
     * Registration object containing the service event notification interface, and lease on
     * session data stored at the service agent.
     */
    private EventRegistration er = null;

    /**
     * Constructs a new ClientHelper object.
     */
    public ClientHelper (ClientHelperCallbackInterface client, Entry entryAttribute, String name) {
        this.client = client;
        this.serviceClass = GenericServiceInterface.class;
        this.entryAttribute = entryAttribute;
        this.name = name;
        initialize();
    }

    /**
     * Constructs a new ClientHelper object.
     */
    public ClientHelper (ClientHelperCallbackInterface client, Entry entryAttribute) {
        this(client, entryAttribute, entryAttribute.toString());
    }

    /**
     * Initializes communications with the service agent.
     */
    private void initialize () {
        Log.makeLog();
        Log.current.println("Initializing client for service matching " + entryAttribute);
        // Provide security manager required to download classes via RMI.
        SecurityManager securityManager = System.getSecurityManager();
        if ((securityManager == null) || (!(securityManager instanceof RMISecurityManager))) {
            Log.current.println("Setting RMI security manager");
            System.setSecurityManager(new RMISecurityManager());
        }
        ServiceFinder sf = null;
        try {
            // Find the service by its interface type.  Cannot specify a class name because the stub
            // of the service is the object registered at the lookup service.  The stub generated by
            // the RMIC utility does not permit the access to the stub classname.
            sf = new ServiceFinder(serviceClass, entryAttribute);
        }
        catch (IOException e) {
            Log.current.errorPrintln("Error finding service agent " + e);
        }
        serviceInterface = (GenericServiceInterface)(sf.getObject());
        Log.current.println("Found service agent " + name);
        // Employ a lease renewal manager to automatically renew leases
        // on our behalf.
        lrm = new LeaseRenewalManager();
        RemoteEventListener rel = null;
        try {
            rel = new ServiceEventHandler(client);
        }
        catch (RemoteException e) {
            Log.current.errorPrintln("Error creating listener for service event notifications " + e);
        }
        try {
            // Sign up to be notified of events from the service, and obtain
            // a lease on session data stored at the service agent on our behalf.
            er = serviceInterface.requestNofication(Lease.FOREVER, rel, null);
            Log.current.println("Registered with service agent to receive shutdown event notifications.");
        }
        catch (RemoteException e) {
            Log.current.errorPrintln("Error registering with service for shutdown event notifications "
                    + e);
        }
        catch (LeaseDeniedException e) {
            Log.current.errorPrintln("Lease denied when registering with service for shutdown event notifications "
                    + e);
        }
        try {
            lrm.renewUntil(er.getLease(), Lease.FOREVER, null);
            // Obtain a lease from the service agent.
            serviceLease = serviceInterface.requestServiceLease(Lease.FOREVER);
            Log.current.println("Obtained lease from service agent for provided services.");
            lrm.renewUntil(serviceLease, Lease.FOREVER, null);
        }
        catch (Exception e) {
            e.printStackTrace();
            finalize();
        }
    }

    /**
     * Gets the service agent object.
     */
    public GenericServiceInterface getService () {
        return  serviceInterface;
    }

    /**
     * Gets the service lease object.
     */
    public Lease getServiceLease () {
        return  serviceLease;
    }

    /**
     * Stops communications with the service agent.
     */
    public void finalize () {
        Log.current.println("Quiting communications with " + serviceInterface);
        Log.current.println("Cancelling service event notification lease");
        try {
            // Cancel the event notification, and session data storage lease with the
            // service agent.
            lrm.cancel(er.getLease());
        }
        catch (RemoteException e) {
            Log.current.errorPrintln("Error when cancelling lease " + e);
        }
        catch (UnknownLeaseException e) {
            Log.current.println("Error ignored when cancelling lease " + e);
        }
        Log.current.println("Cancelling service lease");
        try {
            // Cancel the service request lease with the service agent.
            lrm.cancel(serviceLease);
        }
        catch (RemoteException e) {
            Log.current.errorPrintln("Error when cancelling lease " + e);
        }
        catch (UnknownLeaseException e) {
            Log.current.println("Error ignored when cancelling lease " + e);
        }
    }
}



